--------------------------------------------------------------------------------
üìå Question 31
--------------------------------------------------------------------------------
You are developing a solution that will use Azure messaging services.

You need to ensure that the solution uses a publish-subscribe model and 
eliminates the need for constant polling.

What are two possible ways to achieve the goal? Each correct answer presents 
a complete solution.

1. A. Service Bus
2. B. Event Hub
3. C. Event Grid
4. D. Queue

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
1. A. Service Bus
2. C. Event Grid

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
1.  **Azure Service Bus (Option A):**
    - **Pub/Sub Model:** Service Bus supports **Topics and Subscriptions**, 
      which is a classic implementation of the publish-subscribe pattern. One 
      publisher sends a message to a topic, and multiple subscribers receive 
      their own copy of the message.
    - **Eliminates Constant Polling:** Service Bus supports protocols like 
      **AMQP**, which allows the broker to push messages to the client as soon 
      as they arrive (or use **Long Polling**), rather than the client having 
      to constantly poll the server and receive empty responses (busy waiting).

2.  **Azure Event Grid (Option C):**
    - **Pub/Sub Model:** Event Grid is a fully managed event routing service 
      built specifically on the publish-subscribe model. It routes events from 
      sources to subscribers.
    - **Eliminates Constant Polling:** Event Grid uses a **Push** delivery 
      mechanism. It sends HTTP requests (Webhooks) to event handlers when an 
      event occurs, completely removing the need for the handler to poll for 
      updates.

3.  **Why others are incorrect:**
    - **B. Event Hub:** While Event Hubs supports a form of pub/sub via 
      Consumer Groups, it is primarily a data streaming platform where consumers 
      typically **pull** (poll) data from partitions.
    - **D. Queue:** Queues (both Storage Queues and Service Bus Queues) 
      typically follow a **Point-to-Point** model (one sender, one receiver), 
      not a Publish-Subscribe model.

--------------------------------------------------------------------------------
üìå Question 32
--------------------------------------------------------------------------------
You are developing an Azure solution to collect point-of-sale (POS) device data 
from 2,000 stores located throughout the world. A single device can produce 
2 megabytes (MB) of data every 24 hours. Each store location has one to five 
devices that send data.

You must store the device data in Azure Blob storage. Device data must be 
correlated based on a device identifier. Additional stores are expected to 
open in the future.

You need to implement a solution to receive the device data.

Solution: Provision an Azure Notification Hub. Register all devices with the 
hub.

Does the solution meet the goal?

1. A. Yes
2. B. No

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
B. No

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
1.  **Wrong Service Purpose:**
    - **Azure Notification Hubs** is a service designed for sending push 
      notifications *to* mobile devices (iOS, Android, Windows, etc.) from a 
      backend.
    - It is **not** designed for *ingesting* telemetry or data streams *from* 
      devices. It cannot receive 2MB data payloads from thousands of devices 
      and store them in Blob Storage.

2.  **Correct Service:**
    - The scenario describes a classic IoT or data ingestion pattern.
    - The appropriate services would be **Azure Event Hubs** (for big data 
      streaming) or **Azure IoT Hub** (for bi-directional device communication 
      and management).
    - Specifically, **Azure Event Hubs** with the **Capture** feature enabled 
      would be the ideal solution to ingest the data and automatically save it 
      to Azure Blob Storage, as discussed in previous variations of this 
      question.

--------------------------------------------------------------------------------
üìå Question 33
--------------------------------------------------------------------------------
You are working for Contoso, Ltd.
You define an API Policy object by using the following XML markup:

```xml
<set-variable name="bodySize" value="@(context.Request.Headers["Content-Length"][0])" />
<choose>
    <when condition="@(int.Parse(context.Variables.GetValueOrDefault<string>("bodySize"))<512000)">
    </when>
    <otherwise>
        <rewrite-uri template="/put"/>
        <set-backend-service base-url="http://contoso.com/api/9.1/"/>
    </otherwise>
</choose>
```

For each of the following statements, select Yes if the statement is true. 
Otherwise, select No.

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
1. The XML segment belongs in the <inbound> section of the policy: **Yes**
2. If the body size is > 256k, an error will occur: **No**
3. If the request is http://contoso.com/api/9.2/, the policy will retain the higher version: **No**

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
1. **Yes**: The policies `rewrite-uri` and `set-backend-service` are used to 
   modify the request URL and the target backend *before* the request is 
   forwarded. These operations are only valid in the `<inbound>` section of 
   the API Management policy.

2. **No**: 
   - The condition checks if `bodySize < 512000`.
   - 256k (approx. 262,144 bytes) is less than 512,000, so the condition is 
     **true**. The logic enters the `<when>` block, which is empty, so the 
     request proceeds normally.
   - Even if the body size were larger (making the condition false), the 
     `<otherwise>` block simply rewrites the URI and changes the backend; it 
     does **not** raise an error.

3. **No**: 
   - If the condition fails (i.e., the body size is >= 512,000), the 
     `<otherwise>` block executes.
   - This block explicitly sets the backend service to 
     `http://contoso.com/api/9.1/`.
   - Therefore, if a request comes in for version `9.2` with a large body, it 
     will be routed to version `9.1`. Since the policy downgrades the version 
     in this scenario, it does not "retain the higher version."

--------------------------------------------------------------------------------
üìå Question 34
--------------------------------------------------------------------------------
You have the following requirements:
- Queue size must not grow larger than 80 gigabytes (GB).
- Use first-in-first-out (FIFO) ordering of messages.
- Minimize Azure costs.

You need to implement the messaging solution.

Solution: Use the .Net API to add a message to an Azure Service Bus Queue 
from the mobile application. Create an Azure Function App that uses an Azure 
Service Bus Queue trigger.

Does the solution meet the goal?

A. Yes
B. No

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
A. Yes

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
1.  **FIFO Ordering (Met):**
    - **Azure Service Bus Queues** support First-In-First-Out (FIFO) message 
      delivery (unlike Azure Storage Queues). This satisfies the ordering 
      requirement.

2.  **Minimize Costs (Met):**
    - The solution uses **Azure Functions** (serverless) to process messages. 
      Since the scenario states "Messages may not be sent to the service 
      consistently," a Consumption Plan Function App is highly cost-effective 
      because you only pay when code runs. This is a significant improvement 
      over using a dedicated Virtual Machine (as seen in previous variations).

3.  **Queue Size (Met):**
    - While basic Service Bus queues have smaller limits (e.g., 1 GB), 
      **Partitioned Service Bus Queues** in the Standard tier can support up 
      to **80 GB** (16 partitions √ó 5 GB). This satisfies the size requirement.

**Conclusion:** This solution correctly selects the messaging service that 
supports FIFO (Service Bus) and the compute service that minimizes costs 
(Azure Functions).

--------------------------------------------------------------------------------
üìå Question 35
--------------------------------------------------------------------------------
You are developing an e-commerce solution that uses a microservice architecture.

You need to design a communication backplane for communicating transactional 
messages between various parts of the solution. Messages must be communicated 
in first-in-first-out (FIFO) order.

What should you use?

A. Azure Storage Queue
B. Azure Event Hub
C. Azure Service Bus
D. Azure Event Grid

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
C. Azure Service Bus

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
1.  **Azure Service Bus (Correct):**
    - **Transactional Messaging:** Service Bus is specifically designed for 
      high-value enterprise messaging, such as financial transactions and 
      e-commerce orders, where data integrity is critical.
    - **FIFO Ordering:** Service Bus guarantees First-In-First-Out (FIFO) 
      message delivery (using Message Sessions), ensuring that orders are 
      processed in the exact sequence they were received.

2.  **Why others are incorrect:**
    - **A. Azure Storage Queue:** Does **not** guarantee FIFO ordering. It is 
      designed for simple, large-scale work queues where order is not critical.
    - **B. Azure Event Hub:** Designed for big data streaming and telemetry 
      ingestion (millions of events per second), not for transactional 
      messaging between microservices.
    - **D. Azure Event Grid:** An event routing service for reactive 
      programming (reacting to state changes). It does not guarantee strict 
      ordering and is not meant for transactional data payloads.

--------------------------------------------------------------------------------
üìå Question 36
--------------------------------------------------------------------------------
You develop and deploy several APIs to Azure API Management.
You create a policy fragment named APICounts.
The policy fragment must be reused across various scopes and APIs. The policy fragment must be applied to all APIs and run when a calling system invokes any API.
You need to implement the policy fragment.

```xml
  <policies>
    <xml>
        <xml xml="APICounts" />
        <base />
    </xml>
    . . .
</policies>
```

Available Options (XML Elements)
- name
- inbound
- outbound
- set-variable
- fragment-id
- include-fragment

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------

```xml
  <policies>
    <inbound>
        <include-fragment fragment-id="APICounts" />
        <base />
    </inbound>
    . . .
</policies>
```

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
1. <inbound>: The policy must run "when a calling system invokes any API", which is the inbound phase (request processing).
2. <include-fragment>: The element used to reference and insert a shared policy fragment.
3. fragment-id="APICounts": The attribute that specifies the unique name of the fragment to apply.
