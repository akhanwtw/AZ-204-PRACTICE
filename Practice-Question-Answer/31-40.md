--------------------------------------------------------------------------------
üìå Question 31
--------------------------------------------------------------------------------
You are developing a solution that will use Azure messaging services.

You need to ensure that the solution uses a publish-subscribe model and 
eliminates the need for constant polling.

What are two possible ways to achieve the goal? Each correct answer presents 
a complete solution.

1. A. Service Bus
2. B. Event Hub
3. C. Event Grid
4. D. Queue

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
1. A. Service Bus
2. C. Event Grid

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
1.  **Azure Service Bus (Option A):**
    - **Pub/Sub Model:** Service Bus supports **Topics and Subscriptions**, 
      which is a classic implementation of the publish-subscribe pattern. One 
      publisher sends a message to a topic, and multiple subscribers receive 
      their own copy of the message.
    - **Eliminates Constant Polling:** Service Bus supports protocols like 
      **AMQP**, which allows the broker to push messages to the client as soon 
      as they arrive (or use **Long Polling**), rather than the client having 
      to constantly poll the server and receive empty responses (busy waiting).

2.  **Azure Event Grid (Option C):**
    - **Pub/Sub Model:** Event Grid is a fully managed event routing service 
      built specifically on the publish-subscribe model. It routes events from 
      sources to subscribers.
    - **Eliminates Constant Polling:** Event Grid uses a **Push** delivery 
      mechanism. It sends HTTP requests (Webhooks) to event handlers when an 
      event occurs, completely removing the need for the handler to poll for 
      updates.

3.  **Why others are incorrect:**
    - **B. Event Hub:** While Event Hubs supports a form of pub/sub via 
      Consumer Groups, it is primarily a data streaming platform where consumers 
      typically **pull** (poll) data from partitions.
    - **D. Queue:** Queues (both Storage Queues and Service Bus Queues) 
      typically follow a **Point-to-Point** model (one sender, one receiver), 
      not a Publish-Subscribe model.

--------------------------------------------------------------------------------
üìå Question 32
--------------------------------------------------------------------------------
You are developing an Azure solution to collect point-of-sale (POS) device data 
from 2,000 stores located throughout the world. A single device can produce 
2 megabytes (MB) of data every 24 hours. Each store location has one to five 
devices that send data.

You must store the device data in Azure Blob storage. Device data must be 
correlated based on a device identifier. Additional stores are expected to 
open in the future.

You need to implement a solution to receive the device data.

Solution: Provision an Azure Notification Hub. Register all devices with the 
hub.

Does the solution meet the goal?

1. A. Yes
2. B. No

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
B. No

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
1.  **Wrong Service Purpose:**
    - **Azure Notification Hubs** is a service designed for sending push 
      notifications *to* mobile devices (iOS, Android, Windows, etc.) from a 
      backend.
    - It is **not** designed for *ingesting* telemetry or data streams *from* 
      devices. It cannot receive 2MB data payloads from thousands of devices 
      and store them in Blob Storage.

2.  **Correct Service:**
    - The scenario describes a classic IoT or data ingestion pattern.
    - The appropriate services would be **Azure Event Hubs** (for big data 
      streaming) or **Azure IoT Hub** (for bi-directional device communication 
      and management).
    - Specifically, **Azure Event Hubs** with the **Capture** feature enabled 
      would be the ideal solution to ingest the data and automatically save it 
      to Azure Blob Storage, as discussed in previous variations of this 
      question.

--------------------------------------------------------------------------------
üìå Question 33
--------------------------------------------------------------------------------
You are working for Contoso, Ltd.
You define an API Policy object by using the following XML markup:

```xml
<set-variable name="bodySize" value="@(context.Request.Headers["Content-Length"][0])" />
<choose>
    <when condition="@(int.Parse(context.Variables.GetValueOrDefault<string>("bodySize"))<512000)">
    </when>
    <otherwise>
        <rewrite-uri template="/put"/>
        <set-backend-service base-url="http://contoso.com/api/9.1/"/>
    </otherwise>
</choose>
```

For each of the following statements, select Yes if the statement is true. 
Otherwise, select No.

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
1. The XML segment belongs in the <inbound> section of the policy: **Yes**
2. If the body size is > 256k, an error will occur: **No**
3. If the request is http://contoso.com/api/9.2/, the policy will retain the higher version: **No**

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
1. **Yes**: The policies `rewrite-uri` and `set-backend-service` are used to 
   modify the request URL and the target backend *before* the request is 
   forwarded. These operations are only valid in the `<inbound>` section of 
   the API Management policy.

2. **No**: 
   - The condition checks if `bodySize < 512000`.
   - 256k (approx. 262,144 bytes) is less than 512,000, so the condition is 
     **true**. The logic enters the `<when>` block, which is empty, so the 
     request proceeds normally.
   - Even if the body size were larger (making the condition false), the 
     `<otherwise>` block simply rewrites the URI and changes the backend; it 
     does **not** raise an error.

3. **No**: 
   - If the condition fails (i.e., the body size is >= 512,000), the 
     `<otherwise>` block executes.
   - This block explicitly sets the backend service to 
     `http://contoso.com/api/9.1/`.
   - Therefore, if a request comes in for version `9.2` with a large body, it 
     will be routed to version `9.1`. Since the policy downgrades the version 
     in this scenario, it does not "retain the higher version."

--------------------------------------------------------------------------------
üìå Question 34
--------------------------------------------------------------------------------
You have the following requirements:
- Queue size must not grow larger than 80 gigabytes (GB).
- Use first-in-first-out (FIFO) ordering of messages.
- Minimize Azure costs.

You need to implement the messaging solution.

Solution: Use the .Net API to add a message to an Azure Service Bus Queue 
from the mobile application. Create an Azure Function App that uses an Azure 
Service Bus Queue trigger.

Does the solution meet the goal?

A. Yes
B. No

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
A. Yes

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
1.  **FIFO Ordering (Met):**
    - **Azure Service Bus Queues** support First-In-First-Out (FIFO) message 
      delivery (unlike Azure Storage Queues). This satisfies the ordering 
      requirement.

2.  **Minimize Costs (Met):**
    - The solution uses **Azure Functions** (serverless) to process messages. 
      Since the scenario states "Messages may not be sent to the service 
      consistently," a Consumption Plan Function App is highly cost-effective 
      because you only pay when code runs. This is a significant improvement 
      over using a dedicated Virtual Machine (as seen in previous variations).

3.  **Queue Size (Met):**
    - While basic Service Bus queues have smaller limits (e.g., 1 GB), 
      **Partitioned Service Bus Queues** in the Standard tier can support up 
      to **80 GB** (16 partitions √ó 5 GB). This satisfies the size requirement.

**Conclusion:** This solution correctly selects the messaging service that 
supports FIFO (Service Bus) and the compute service that minimizes costs 
(Azure Functions).

--------------------------------------------------------------------------------
üìå Question 35
--------------------------------------------------------------------------------
You are developing an e-commerce solution that uses a microservice architecture.

You need to design a communication backplane for communicating transactional 
messages between various parts of the solution. Messages must be communicated 
in first-in-first-out (FIFO) order.

What should you use?

A. Azure Storage Queue
B. Azure Event Hub
C. Azure Service Bus
D. Azure Event Grid

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
C. Azure Service Bus

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
1.  **Azure Service Bus (Correct):**
    - **Transactional Messaging:** Service Bus is specifically designed for 
      high-value enterprise messaging, such as financial transactions and 
      e-commerce orders, where data integrity is critical.
    - **FIFO Ordering:** Service Bus guarantees First-In-First-Out (FIFO) 
      message delivery (using Message Sessions), ensuring that orders are 
      processed in the exact sequence they were received.

2.  **Why others are incorrect:**
    - **A. Azure Storage Queue:** Does **not** guarantee FIFO ordering. It is 
      designed for simple, large-scale work queues where order is not critical.
    - **B. Azure Event Hub:** Designed for big data streaming and telemetry 
      ingestion (millions of events per second), not for transactional 
      messaging between microservices.
    - **D. Azure Event Grid:** An event routing service for reactive 
      programming (reacting to state changes). It does not guarantee strict 
      ordering and is not meant for transactional data payloads.

--------------------------------------------------------------------------------
üìå Question 36
--------------------------------------------------------------------------------
You develop and deploy several APIs to Azure API Management.
You create a policy fragment named APICounts.
The policy fragment must be reused across various scopes and APIs. The policy fragment must be applied to all APIs and run when a calling system invokes any API.
You need to implement the policy fragment.

```xml
  <policies>
    <xml>
        <xml xml="APICounts" />
        <base />
    </xml>
    . . .
</policies>
```

Available Options (XML Elements)
- name
- inbound
- outbound
- set-variable
- fragment-id
- include-fragment

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------

```xml
  <policies>
    <inbound>
        <include-fragment fragment-id="APICounts" />
        <base />
    </inbound>
    . . .
</policies>
```

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
1. <inbound>: The policy must run "when a calling system invokes any API", which is the inbound phase (request processing).
2. <include-fragment>: The element used to reference and insert a shared policy fragment.
3. fragment-id="APICounts": The attribute that specifies the unique name of the fragment to apply.

--------------------------------------------------------------------------------
üìå Question 37
--------------------------------------------------------------------------------
You develop several Azure Functions app functions to process JSON documents 
from a third-party system. The third-party system publishes events to Azure 
Event Grid to include hundreds of event types, such as billing, inventory, 
and shipping updates.

Events must be sent to a single endpoint for the Azure Functions app to 
process. The events must be filtered by event type before processing. You 
must have authorization and authentication control to partition your tenants 
to receive the event data.

You need to configure Azure Event Grid.

Which configuration should you use?

**Requirements:**
1. Third-party system endpoint to send events
2. Azure Functions app endpoint to handle filtered events

**Options:**
- A. system topic
- B. custom topic
- C. event domain
- D. event subscription

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
1. Third-party system endpoint to send events: **C. event domain**
2. Azure Functions app endpoint to handle filtered events: **D. event subscription**

**Note on Incorrect Exam Dumps:**
You may see other sources (or dumps) suggesting *System Topic* for the ingress 
and *Event Domain* for the egress. This is incorrect.
1. **System Topics** are solely for Azure services (like Blob Storage), not 
   third-party apps.
2. **Event Domains** are for managing inputs (ingress) for tenants, not for 
   defining the handler destination (egress).
3. **Event Subscriptions** are explicitly the mechanism used to define 
   endpoints (handlers) and filters.

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
1.  **Event Domain (Requirement 1):**
    -   **Multi-tenancy:** The scenario requires "authorization and authentication 
        control to partition your tenants." **Event Domains** are management 
        tools specifically designed for large-scale, multi-tenant applications. 
        They allow you to manage the flow of events to thousands of individual 
        topics (one per tenant) while exposing a single publishing endpoint to 
        the source system.
    -   **Not Custom Topic:** While a custom topic is used for third-party/custom 
        apps, it is a single resource. Managing auth/auth for individual tenants 
        on a single custom topic is difficult compared to the built-in 
        partitioning of Event Domains unless you create a separate topic for 
        each tenant (which Event Domains automate).
    -   **Not System Topic:** System topics are for Azure services (Blob Storage, 
        IoT Hub, etc.), not third-party systems.

2.  **Event Subscription (Requirement 2):**
    -   **Filtering & Routing:** To send events to a handler (like an Azure 
        Function) and filter them (e.g., by `EventType` or Subject), you 
        must create an **Event Subscription**.
    -   Attributes of the subscription define the destination endpoint (webhook, 
        Azure Function, etc.) and the filter rules.

--------------------------------------------------------------------------------
üìå Question 38 ‚≠ê‚≠ê‚≠ê
--------------------------------------------------------------------------------

You develop a news and blog content app for Windows devices.
A notification must arrive on a user's device when there is a new article available for them to view.
You need to implement push notifications using Azure Notification Hubs.

How should you complete the code segment? 

[Code Segment]
```csharp
string notificationHubName = "contoso_hub";
string notificationHubConnection = "connection_string";
/* 1 */ hub = /* 2 */ . /* 3 */ (notificationHubConnection, notificationHubName);

string windowsToastPayload = 
    @"<toast><visual><binding template=""ToastText01""><text id=""1"">" +
    @"New item to view" + @"</text></binding></visual></toast>";

try
{
    var result = 
        await hub. /* 4 */ (windowsToastPayload);
    ...
}
catch (System.Exception ex)
{
    ...
}
```

[Available Options]
Dropdown 1 (Type):
  - NotificationHubClient
  - NotificationHubClientSettings
  - NotificationHubJob
  - NotificationDetails

Dropdown 2 (Class):
  - NotificationHubClient
  - NotificationHubClientSettings
  - NotificationHubJob
  - NotificationDetails

Dropdown 3 (Method):
  - GetInstallation
  - CreateClientFromConnectionString
  - CreateOrUpdateInstallation
  - PatchInstallation

Dropdown 4 (Method):
  - SendWindowsNativeNotificationAsync
  - SubmitNotificationHubJobAsync
  - ScheduleNotificationAsync
  - SendAppleNativeNotificationAsync

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
```csharp
string notificationHubName = "contoso_hub";
string notificationHubConnection = "connection_string";

// 1. Type: NotificationHubClient
// 2. Class: NotificationHubClient
// 3. Method: CreateClientFromConnectionString
NotificationHubClient hub = NotificationHubClient.CreateClientFromConnectionString(notificationHubConnection, notificationHubName);

string windowsToastPayload = 
    @"<toast><visual><binding template=""ToastText01""><text id=""1"">" +
    @"New item to view" + @"</text></binding></visual></toast>";

try
{
    var result = 
        // 4. Method: SendWindowsNativeNotificationAsync
        await hub.SendWindowsNativeNotificationAsync(windowsToastPayload);
    ...
}
catch (System.Exception ex)
{
    ...
}
```
--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------

1. NotificationHubClient (Type)
   This is the primary client class in the Microsoft.Azure.NotificationHubs namespace used for sending notifications and managing registrations.

2. NotificationHubClient (Class)
   You access the static factory method `CreateClientFromConnectionString` directly from the `NotificationHubClient` class type.

3. CreateClientFromConnectionString (Method)
   This static method creates a new instance of `NotificationHubClient`. It requires the connection string (with Listen rights) and the hub name.

4. SendWindowsNativeNotificationAsync (Method)
   The payload is a Windows Toast XML string (`<toast>...`). 
   - `SendWindowsNativeNotificationAsync` handles native Windows payloads.
   - `SendAppleNativeNotificationAsync` is for iOS (APNs).
   - `ScheduleNotificationAsync` is for scheduling future delivery (not requested here).
   - `SubmitNotificationHubJobAsync` is used for bulk operations/jobs.
  
--------------------------------------------------------------------------------
üìå Question 39
--------------------------------------------------------------------------------
You are developing an Azure Service application that processes queue data when it receives a message from a mobile application. Messages may not be sent to the service consistently.

You have the following requirements:
*   Queue size must not grow larger than 80 gigabytes (GB).
*   Use first-in-first-out (FIFO) ordering of messages.
*   Minimize Azure costs.

You need to implement the messaging solution.

**Solution:** Use the .Net API to add a message to an Azure Storage Queue from the mobile application. Create an Azure Function App that uses an Azure Storage Queue trigger.

Does the solution meet the goal?

1. A. Yes
2. B. No

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
B. No

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
The proposed solution uses **Azure Storage Queues**, which fail to meet the critical **FIFO (First-In-First-Out)** requirement.

1.  **FIFO Requirement**: Azure Storage Queues do **not** guarantee first-in-first-out ordering. Messages are typically retrieved in insertion order, but due to visibility timeouts and parallel processing, they can be processed out of sequence. To achieve guaranteed FIFO, **Azure Service Bus** (specifically with Sessions) is required.
2.  **Queue Size**: Azure Storage Queues can easily handle 80 GB (up to the storage account limit, usually 500 TB+), which meets the size requirement, but the ordering failure invalidates the solution.
3.  **Cost**: While Azure Storage Queues are the lowest-cost option (meeting the "Minimize Azure costs" requirement), technical capabilities (FIFO) typically take precedence over cost optimization in these scenarios.

--------------------------------------------------------------------------------
üìå Question 40
--------------------------------------------------------------------------------
A company is implementing a publish-subscribe (Pub/Sub) messaging component by using Azure Service Bus. You are developing the first subscription application.

In the Azure portal, you see that messages are being sent to the subscription for each topic. You create and initialize a subscription client object by supplying the correct details, but the subscription application is still not consuming the messages.

You need to ensure that the subscription client processes all messages.

Which code segment should you use?

1. A. await subscriptionClient.AddRuleAsync(new RuleDescription(RuleDescription.DefaultRuleName, new TrueFilter()));
2. B. subscriptionClient = new SubscriptionClient(ServiceBusConnectionString, TopicName, SubscriptionName);
3. C. await subscriptionClient.CloseAsync();
4. D. subscriptionClient.RegisterMessageHandler(ProcessMessagesAsync, messageHandlerOptions);

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
D. subscriptionClient.RegisterMessageHandler(ProcessMessagesAsync, messageHandlerOptions);

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
To begin consuming messages in the (legacy) `Microsoft.Azure.ServiceBus` library, you must explicitly start the message pump by registering a handler.

1.  **RegisterMessageHandler**: The `SubscriptionClient` object does not automatically poll for messages upon instantiation. You must call `RegisterMessageHandler` to Attach the callback method (`ProcessMessagesAsync`) that contains the business logic for processing standard messages. This initiates the message pump which continuously receives messages from the Service Bus.
2.  **Why Option A is incorrect**: `AddRuleAsync` manages the rules/filters that determine which Topic messages are routed *into* the Subscription. Since the question states "messages are being sent to the subscription", the routing logic is already working; the client app just isn't picking them up.
3.  **Why Option B is incorrect**: Re-instantiating the `SubscriptionClient` creates a new connection object but acts exactly like the previous one‚Äîit will remain idle without a registered handler.
4.  **Why Option C is incorrect**: `CloseAsync()` shuts down the connection to the Service Bus, which is the exact opposite of ensuring messages are processed.

*Note: While newer SDKs (`Azure.Messaging.ServiceBus`) use `ServiceBusProcessor`, the syntax in the code options specifically targets the older `Microsoft.Azure.ServiceBus` SDK pattern.*
