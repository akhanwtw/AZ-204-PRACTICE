--------------------------------------------------------------------------------
üìå Question 111
--------------------------------------------------------------------------------
After you answer a question in this section, you will NOT be able to return to it. As a result, these questions will not appear in the review screen.

You are developing a website that will run as an Azure Web App. Users will authenticate by using their Azure Active Directory (Azure AD) credentials.

You plan to assign users one of the following permission levels for the website: admin, normal, and reader. A user's Azure AD group membership must be used to determine the permission level.

You need to configure authorization.

**Solution:**

*   Create a new Azure AD application. In the application's manifest, define application roles that match the required permission levels for the application.
*   Assign the appropriate Azure AD group to each role. In the website, use the value of the roles claim from the JWT for the user to determine permissions.

**Does the solution meet the goal?**

- A. Yes
- B. No

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
**A. Yes**

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**Why "Yes" is the correct choice:**

This is the recommended best practice for role-based access control (RBAC) with Azure AD for custom applications.

1.  **Application Roles (App Roles):** By defining roles (admin, normal, reader) in the **Application Manifest**, you create a specific authorization schema for your application that is understandable by Azure AD.
2.  **Decoupling Logic:** Instead of hardcoding Azure AD Group Object IDs into your application code (which makes the code brittle and hard to manage), you map the Groups to the App Roles in the Enterprise Application settings in the Azure Portal.
3.  **The `roles` Claim:** When a user logs in, if they belong to a group that is assigned to an App Role, Azure AD automatically emits a `roles` claim in the JSON Web Token (JWT) containing the role name (e.g., "admin").
4.  **Simplicity:** The application code simply checks `User.IsInRole("admin")` (or equivalent), fulfilling the requirement to use group membership to determine permissions without verifying group IDs directly.

**References:**
*   [Add app roles to your application and receive them in the token](https://learn.microsoft.com/en-us/entra/identity-platform/howto-add-app-roles-in-azure-ad-apps)

--------------------------------------------------------------------------------
üìå Question 112
--------------------------------------------------------------------------------
After you answer a question in this section, you will NOT be able to return to it. As a result, these questions will not appear in the review screen.

You are developing a website that will run as an Azure Web App. Users will authenticate by using their Azure Active Directory (Azure AD) credentials.

You plan to assign users one of the following permission levels for the website: admin, normal, and reader. A user's Azure AD group membership must be used to determine the permission level.

You need to configure authorization.

**Solution:**

*   Configure and use Integrated Windows Authentication in the website.
*   In the website, query Microsoft Graph API to load the groups to which the user is a member.

**Does the solution meet the goal?**

- A. Yes
- B. No

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
**B. No**

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**Why "No" is the correct answer:**

1.  **Incorrect Authentication Mechanism:** Integrated Windows Authentication (IWA) is a legacy authentication protocol (Kerberos/NTLM) designed primarily for on-premises, domain-joined intranet environments. It is **not** the standard or recommended method for authenticating users in a cloud-hosted Azure Web App using Azure Active Directory over the internet.
2.  **Standard Approach:** The standard mechanism for Azure Web Apps is **OpenID Connect** (OIDC) and OAuth 2.0. You would typically use Azure App Service Authentication ("Easy Auth") or a library like `Microsoft.Identity.Web`.
3.  **Better Group Handling:** While querying Microsoft Graph is possible, the preferred method for authorization is to configure the Azure AD Application Manifest to simply emit group claims (`"groupMembershipClaims": "SecurityGroup"`) or use App Roles. This delivers the necessary authorization data directly in the user's ID Token, avoiding the performance penalty and complexity of making manual Graph API calls for basic role checks.

**References:**
*   [Authentication and authorization in Azure App Service](https://learn.microsoft.com/en-us/azure/app-service/overview-authentication-authorization)
*   [Configure the 'groups' claim for applications with Azure Active Directory](https://learn.microsoft.com/en-us/entra/identity-platform/optional-claims#configure-groups-optional-claims)

--------------------------------------------------------------------------------
üìå Question 113
--------------------------------------------------------------------------------
After you answer a question in this section, you will NOT be able to return to it. As a result, these questions will not appear in the review screen.

You are developing a website that will run as an Azure Web App. Users will authenticate by using their Azure Active Directory (Azure AD) credentials.

You plan to assign users one of the following permission levels for the website: admin, normal, and reader. A user's Azure AD group membership must be used to determine the permission level.

You need to configure authorization.

**Solution:**

*   Create a new Azure AD application. In the application's manifest, set value of the `groupMembershipClaims` option to **All**.
*   In the website, use the value of the `groups` claim from the JWT for the user to determine permissions.

**Does the solution meet the goal?**

- A. Yes
- B. No

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
**A. Yes**

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**Why "Yes" is the correct answer:**

1.  **Mechanism:** Setting `groupMembershipClaims` to `All` (or `SecurityGroup`) in the Azure AD Application Manifest instructs Azure AD to include the Object IDs (OIDs) of the groups the user belongs to within the ID Token or Access Token issued to the application.
2.  **Implementation:** The code can then inspect the `groups` claim (an array of strings), compare the OIDs against known values (e.g., "If Group ID == `abc-123`, then Role = Admin"), and grant access accordingly.
3.  **Meeting Requirements:** This creates a direct link between Azure AD group membership and application permission levels, satisfying the goal.

**Caveat compared to App Roles:**
While this solution *works* and is a supported pattern, it is often considered less architecturaly clean than using **App Roles** (where you define roles like "Admin" in the manifest and assign groups to them). Using App Roles abstracts the Group IDs away from the code. However, utilizing the `groups` claim is a fully functional and valid solution to the problem described.

**References:**
*   [Configure optional claims (groups)](https://learn.microsoft.com/en-us/entra/identity-platform/optional-claims#configure-groups-optional-claims)

--------------------------------------------------------------------------------
üìå Question 114
--------------------------------------------------------------------------------
After you answer a question in this section, you will NOT be able to return to it. As a result, these questions will not appear in the review screen.

You are developing a website that will run as an Azure Web App. Users will authenticate by using their Azure Active Directory (Azure AD) credentials.

You plan to assign users one of the following permission levels for the website: admin, normal, and reader. A user's Azure AD group membership must be used to determine the permission level.

You need to configure authorization.

**Solution:** Configure the Azure Web App for the website to allow only authenticated requests and require Azure AD log on.

**Does the solution meet the goal?**

- A. Yes
- B. No

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
**B. No**

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**Why "No" is the correct answer:**

1.  **Authentication vs. Authorization:** The solution described simply enables **Authentication** (verifying who the user is). It ensures unauthorized users cannot access the site at all.
2.  **Missing Logic:** It does **not** actually implement the **Authorization** logic required to distinguish between "admin", "normal", and "reader" levels. Enabling "Easy Auth" does not automatically map group memberships to application permissions.
3.  **Requirement Gap:** To meet the goal, you must perform additional configuration, such as defining **App Roles** in the Azure AD manifest and assigning groups to them, or configuring **Group Claims** and writing code to inspect those claims. The proposed solution is incomplete.

**References:**
*   [Authentication and authorization in Azure App Service](https://learn.microsoft.com/en-us/azure/app-service/overview-authentication-authorization)


--------------------------------------------------------------------------------
üìå Question 115
--------------------------------------------------------------------------------
After you answer a question in this section, you will NOT be able to return to it. As a result, these questions will not appear in the review screen.

You develop Azure solutions.

You must grant a virtual machine (VM) access to specific resource groups in Azure Resource Manager.

You need to obtain an Azure Resource Manager access token.

**Solution:** Use the Reader role-based access control (RBAC) role to authenticate the VM with Azure Resource Manager.

**Does the solution meet the goal?**

- A. Yes
- B. No

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
**B. No**

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**Why "No" is the correct answer:**

1.  **RBAC is Authorization, not Authentication:** The Reader role is an **Authorization** mechanism (it defines *what* access permission an identity has, specifically read-only access). It is not a method for **Authentication** (proving *who* the identity is) or for retrieving access tokens.
2.  **Missing Identity Mechanism:** To authenticated a VM, you must enable a **Managed Identity** (either System-assigned or User-assigned) on the VM.
3.  **Token Retrieval Method:** To actually **obtain** the access token (as requested by the question), code running inside the VM must make a request to the local Azure Instance Metadata Service (IMDS) identity endpoint (`http://169.254.169.254/metadata/identity/oauth2/token`). Simply assigning the Reader role does not provide the token itself.

**References:**
*   [Managed identities for Azure resources](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/overview)
*   [Azure RBAC documentation](https://learn.microsoft.com/en-us/azure/role-based-access-control/overview)


--------------------------------------------------------------------------------
üìå Question 116
--------------------------------------------------------------------------------
After you answer a question in this section, you will NOT be able to return to it. As a result, these questions will not appear in the review screen.

You develop Azure solutions.

You must grant a virtual machine (VM) access to specific resource groups in Azure Resource Manager.

You need to obtain an Azure Resource Manager access token.

**Solution:** Use an X.509 certificate to authenticate the VM with Azure Resource Manager.

**Does the solution meet the goal?**

- A. Yes
- B. No

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
**B. No**

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**Why "No" is the correct answer:**

1.  **Best Practice (Managed Identity):** The standard, secure, and recommended way to grant an Azure Virtual Machine access to Azure Resource Manager is to use **Managed Identities for Azure Resources** (formerly MSI). This feature provides the VM with an automatically managed identity in Azure AD, eliminating the need to manage credentials.
2.  **Certificate vs. Identity:** Using an X.509 certificate typically implies creating a standalone **Service Principal** (App Registration), uploading the certificate, deploying the certificate file to the VM, and managing its lifecycle/rotation manually. While this setup *can* technically allow code on the VM to authenticate, it authenticates the *Service Principal*, not the *VM itself*, and introduces significant credential management overhead.
3.  **The "Yes" Solution:** The correct solution involves using the local **Azure Instance Metadata Service (IMDS)** endpoint (`http://169.254.169.254/metadata/identity/oauth2/token`) available to the VM when Managed Identity is enabled.

**References:**
*   [Managed identities for Azure resources](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/overview)


--------------------------------------------------------------------------------
üìå Question 117
--------------------------------------------------------------------------------
Your company is developing an Azure API hosted in Azure.

You need to implement authentication for the Azure API to access other Azure resources. You have the following requirements:

‚úë All API calls must be authenticated.
‚úë Callers to the API must not send credentials to the API.

Which authentication mechanism should you use?

- A. Basic
- B. Anonymous
- C. Managed identity
- D. Client certificate

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
**C. Managed identity**

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**Why "Managed identity" is the correct choice:**

1.  **Accessing Other Resources:** The question specifically asks about authentication for the *Azure API* to access *other Azure resources* (like SQL Database, Key Vault, Storage, etc.).
2.  **No Credentials:** Managed Identities provide an automatically managed identity in Azure Active Directory (Microsoft Entra ID) for applications. When using a Managed Identity, the code running on the Azure API service retrieves a token from the local Azure instance metadata service. The application code **never handles or stores credentials** (like a password or client secret), satisfying the requirement that callers/developers do not handle credentials.
3.  **Authenticated Calls:** The traffic between the Azure API and the downstream Azure resource is authenticated using the Azure AD token obtained via the Managed Identity.

**Why other options are incorrect:**
*   **A. Basic:** Basic authentication requires sending a username and password (credentials) in the header, violating the "must not send credentials" requirement.
*   **B. Anonymous:** This violates the requirement that "All API calls must be authenticated."
*   **D. Client certificate:** While secure, this requires managing and deploying the certificate (a form of credential) to the application, and the application must present it. Managed Identity abstracts this credential management away entirely.

**References:**
*   [What are managed identities for Azure resources?](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/overview)


--------------------------------------------------------------------------------
üìå Question 118
--------------------------------------------------------------------------------
After you answer a question in this section, you will NOT be able to return to it. As a result, these questions will not appear in the review screen.

You are developing a medical records document management website. The website is used to store scanned copies of patient intake forms.

If the stored intake forms are downloaded from storage by a third party, the contents of the forms must not be compromised.

You need to store the intake forms according to the requirements.

**Solution:** Store the intake forms as Azure Key Vault secrets.

**Does the solution meet the goal?**

- A. Yes
- B. No

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
**B. No**

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**Why "No" is the correct answer:**

1.  **Wrong Use Case:** Azure Key Vault is designed to store **Secrets** (passwords, connection strings, API keys) and **Keys** (cryptographic keys). It is **not** designed to act as a file system or object storage for documents (BLOBs).
2.  **Size Limits:** Key Vault secrets have strict size limitations (typically 25KB per secret value for standard tiers, though higher for some operations, it is not suitable for scanned images/PDFs). Storing entire files as secrets is architecturally incorrect and cost-prohibitive.
3.  **Correct Solution:** The correct approach (often the "Yes" answer in this specific exam series) is to store the files in **Azure Blob Storage** but use **Client-Side Encryption** with a key stored in Azure Key Vault. This ensures the files in storage are encrypted at rest and unreadable if downloaded by a third party, while using the appropriate storage medium for files.

**References:**
*   [About Azure Key Vault secrets](https://learn.microsoft.com/en-us/azure/key-vault/secrets/about-secrets)
*   [Client-side encryption with .NET for Azure Storage](https://learn.microsoft.com/en-us/azure/storage/common/storage-client-side-encryption)


--------------------------------------------------------------------------------
üìå Question 119
--------------------------------------------------------------------------------
After you answer a question in this section, you will NOT be able to return to it. As a result, these questions will not appear in the review screen.

You are developing a medical records document management website. The website is used to store scanned copies of patient intake forms.

If the stored intake forms are downloaded from storage by a third party, the contents of the forms must not be compromised.

You need to store the intake forms according to the requirements.

**Solution:**

1. Create an Azure Cosmos DB database with Storage Service Encryption enabled.
2. Store the intake forms in the Azure Cosmos DB database.

**Does the solution meet the goal?**

- A. Yes
- B. No

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
**B. No**

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**Why "No" is the correct answer:**

1.  **Wrong Encryption Model:** Storage Service Encryption (SSE) encrypts data **at rest** to protect against physical theft of storage media. However, encryption and decryption are handled transparently by the Azure service. If a third party gains access to the database (even illicitly via valid credentials or an exposed endpoint) and "downloads" the data via the standard API, Azure will automatically decrypt the data before sending it back. The third party would receive the file in plain text, meaning the content **is compromised**.
2.  **Correct Solution Requirement:** To meet the requirement that "contents must not be compromised" if downloaded, you must use **Client-Side Encryption**. In that scenario, the application encrypts the file *before* sending it to Azure. If the raw data is subsequently downloaded by a third party, they receive only encrypted ciphertext and cannot read the document without the specific decryption key held by the application.
3.  **Wrong Storage Service:** While strictly less critical than the encryption flaw, Azure Cosmos DB is widely considered the wrong tool for storing "scanned copies" (Binary Large Objects/BLOBs) of forms. Cosmos DB has a document size limit (typically 2MB), which scanned images often exceed, and it is significantly more expensive per GB than Azure Blob Storage.

**References:**
*   [Azure Data Encryption-at-Rest](https://learn.microsoft.com/en-us/azure/security/fundamentals/encryption-atrest)
*   [Client-side encryption with .NET for Azure Storage](https://learn.microsoft.com/en-us/azure/storage/common/storage-client-side-encryption)


--------------------------------------------------------------------------------
üìå Question
--------------------------------------------------------------------------------
Contoso, Ltd. provides an API to customers by using Azure API Management (APIM). The API authorizes users with a JWT token.

You must implement response caching for the APIM gateway. The caching mechanism must detect the user ID of the client that accesses data for a given location and cache the response for that user ID.

You need to add the following policies to the policies file:
*   A `set-variable` policy to store the detected user identity.
*   A `cache-lookup-value` policy.
*   A `cache-store-value` policy.
*   A `find-and-replace` policy to update the response body with the user profile information.

**To which policy section should you add the policies?**

(Options: Inbound, Outbound)

**Answer Area:**
1. **Set-variable:** ________________
2. **Cache-lookup-value:** ________________
3. **Cache-store-value:** ________________
4. **Find-and-replace:** ________________

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
1. **Set-variable:** Inbound
2. **Cache-lookup-value:** Inbound
3. **Cache-store-value:** Outbound
4. **Find-and-replace:** Outbound

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**1. Set-variable (Inbound)**
To "detect the user ID" from the incoming JWT token (which is in the request header), you must process the request before it reaches the backend or the cache lookup. Variables used for cache keys must be defined in the **Inbound** section so they are available for the subsequent lookup policy.

**2. Cache-lookup-value (Inbound)**
The purpose of looking up a value in the cache is to see if a response is already available *before* forwarding the request to the backend service. Therefore, this check must occur in the **Inbound** processing steps.

**3. Cache-store-value (Outbound)**
You can only store a value in the cache *after* the backend service has processed the request and returned a response. The gateway captures this response in the **Outbound** section and places it into the cache for future requests.

**4. Find-and-replace (Outbound)**
The requirement is to "update the response body". Any modification to the data being returned to the client (response transformation) occurs in the **Outbound** section.

**Policy Example:**
```xml
<policies>
    <inbound>
        <base />
        <!-- 1. Extract ID from JWT -->
        <set-variable name="userId" value="@(context.Request.Headers.GetValueOrDefault("Authorization","").Split(' ')[1].AsJwt().Subject)" />
        <!-- 2. Check cache using variables -->
        <cache-lookup-value vary-by-developer="false" vary-by-developer-groups="false"
             key="@("response-" + context.Variables["userId"])" />
    </inbound>
    <backend>
        <base />
    </backend>
    <outbound>
        <base />
        <!-- 3. Store response in cache -->
        <cache-store-value duration="3600" />
        <!-- 4. Modify response body -->
        <find-and-replace from="OldValue" to="NewValue" />
    </outbound>
</policies>
```

References:
Here is the answer formatted in a single terminal block as requested.

--------------------------------------------------------------------------------
üìå Question 120
--------------------------------------------------------------------------------
Contoso, Ltd. provides an API to customers by using Azure API Management (APIM). The API authorizes users with a JWT token.

You must implement response caching for the APIM gateway. The caching mechanism must detect the user ID of the client that accesses data for a given location and cache the response for that user ID.

You need to add the following policies to the policies file:
*   A `set-variable` policy to store the detected user identity.
*   A `cache-lookup-value` policy.
*   A `cache-store-value` policy.
*   A `find-and-replace` policy to update the response body with the user profile information.

**To which policy section should you add the policies?**

(Options: Inbound, Outbound)

**Answer Area:**
1. **Set-variable:** ________________
2. **Cache-lookup-value:** ________________
3. **Cache-store-value:** ________________
4. **Find-and-replace:** ________________

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
1. **Set-variable:** Inbound
2. **Cache-lookup-value:** Inbound
3. **Cache-store-value:** Outbound
4. **Find-and-replace:** Outbound

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**1. Set-variable (Inbound)**
To "detect the user ID" from the incoming JWT token (which is in the request header), you must process the request before it reaches the backend or the cache lookup. Variables used for cache keys must be defined in the **Inbound** section so they are available for the subsequent lookup policy.

**2. Cache-lookup-value (Inbound)**
The purpose of looking up a value in the cache is to see if a response is already available *before* forwarding the request to the backend service. Therefore, this check must occur in the **Inbound** processing steps.

**3. Cache-store-value (Outbound)**
You can only store a value in the cache *after* the backend service has processed the request and returned a response. The gateway captures this response in the **Outbound** section and places it into the cache for future requests.

**4. Find-and-replace (Outbound)**
The requirement is to "update the response body". Any modification to the data being returned to the client (response transformation) occurs in the **Outbound** section.

**Policy Example:**
```xml
<policies>
    <inbound>
        <base />
        <!-- 1. Extract ID from JWT -->
        <set-variable name="userId" value="@(context.Request.Headers.GetValueOrDefault("Authorization","").Split(' ')[1].AsJwt().Subject)" />
        <!-- 2. Check cache using variables -->
        <cache-lookup-value vary-by-developer="false" vary-by-developer-groups="false"
             key="@("response-" + context.Variables["userId"])" />
    </inbound>
    <backend>
        <base />
    </backend>
    <outbound>
        <base />
        <!-- 3. Store response in cache -->
        <cache-store-value duration="3600" />
        <!-- 4. Modify response body -->
        <find-and-replace from="OldValue" to="NewValue" />
    </outbound>
</policies>
```
**References:**
* [Azure API Management caching policies](https://learn.microsoft.com/en-us/azure/api-management/api-management-caching-policies)
