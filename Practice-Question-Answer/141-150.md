--------------------------------------------------------------------------------
üìå Question 141 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
--------------------------------------------------------------------------------
You are developing a web application that uses the Microsoft identity platform for user and resource authentication. The web application calls several REST APIs.

A REST API call must read the user‚Äôs calendar. The web application requires permission to send an email as the user.

You need to authorize the web application and the API.

Which parameter should you use?

- A. tenant
- B. code_challenge
- C. state
- D. client_id
- E. scope

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
**E. scope**

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**1. The `scope` Parameter**
In the Microsoft identity platform (which implements the OAuth 2.0 and OpenID Connect standards), the **`scope`** parameter is used to request specific permissions from the authorization endpoint.
*   To read a calendar, the application would request a scope like `Calendars.Read`.
*   To send an email as the user, the application would request a scope like `Mail.Send`.
When the user authenticates, they are prompted to consent to these specific scopes. The resulting access token will then contain these scopes, authorizing the API to perform those actions.

**Why others are incorrect:**
*   **A. tenant:** Identifies the Azure AD directory (organization) or indicates a common endpoint (e.g., `common`, `organizations`, or a specific GUID). It does not request specific permissions.
*   **B. code_challenge:** Used in the Authorization Code Flow with PKCE (Proof Key for Code Exchange) to secure the token exchange by preventing authorization code injection attacks.
*   **C. state:** A random value included in the request to maintain state between the request and the callback, primarily used to prevent Cross-Site Request Forgery (CSRF) attacks.
*   **D. client_id:** Unique identifier assigned to the application during registration in Azure AD. It identifies *who* is calling, but not *what permissions* they are requesting.

**References:**
*   [Microsoft identity platform and OAuth 2.0 authorization code flow](https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-auth-code-flow#request-an-authorization-code)
*   [Permissions and consent in the Microsoft identity platform](https://learn.microsoft.com/en-us/entra/identity-platform/permissions-consent-overview)

--------------------------------------------------------------------------------
üìå Question 142
--------------------------------------------------------------------------------
You are developing a web application that uses the Microsoft Identity platform for user and resource authentication. The web application calls several REST APIs.

You are implementing various authentication and authorization flows for the web application.

You need to validate the claims in the authentication token.

Which token type should you use?

**Match the Requirement to the Token type:**

1. **Identify users for the application by using a JWT token that contains claims.**
   [ Access | ID | Refresh | SAML ]

2. **Identify the permissions granted to APIs by using a JWT token that contains claims.**
   [ Access | ID | Refresh | SAML ]

3. **Provide the web application with long-term access to resources on behalf of users without requiring interaction with those users.**
   [ Access | ID | Refresh | SAML ]

4. **Provide XML representations of claims that can be consumed by applications that use WS-Federation.**
   [ Access | ID | Refresh | SAML ]

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
1. **Identify users for the application...:** **ID**
2. **Identify the permissions granted to APIs...:** **Access**
3. **Provide the web application with long-term access...:** **Refresh**
4. **Provide XML representations of claims...:** **SAML**

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**1. ID Token**
An **ID token** is a security token based on the OpenID Connect (OIDC) standard. Its primary purpose is to prove to the client application that the user has been authenticated. It is a JWT (JSON Web Token) that contains claims about the user (like name, email, and subject ID) so the app can identify the user.

**2. Access Token**
An **Access token** is used in the OAuth 2.0 protocol to Authorize access to a resource. It is sent to an API (the resource server) in the HTTP Authorization header. It contains claims about the *permissions* (scopes or roles) granted to the client application, allowing the API to decide whether to grant access. In the specific case of the Microsoft Identity Platform, access tokens are JWTs.

**3. Refresh Token**
A **Refresh token** is used to obtain new access and ID tokens when the current access token expires. This allows the application to maintain access to resources on the user's behalf for a longer period ("offline access") without forcing the user to interactively sign in again every hour.

**4. SAML Token**
**SAML** (Security Assertion Markup Language) tokens are XML-based tokens used in older federation protocols like SAML-P and **WS-Federation**. While modern apps primarily use OIDC/OAuth (JSON), legacy applications or specific enterprise scenarios often require XML-based assertions.

**References:**
*   [ID tokens in the Microsoft identity platform](https://learn.microsoft.com/en-us/entra/identity-platform/id-tokens)
*   [Microsoft identity platform access tokens](https://learn.microsoft.com/en-us/entra/identity-platform/access-tokens)
*   [Microsoft identity platform refresh tokens](https://learn.microsoft.com/en-us/entra/identity-platform/refresh-tokens)

--------------------------------------------------------------------------------
üìå Question 143 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
--------------------------------------------------------------------------------
You are building an application that stores sensitive customer data in Azure Blob storage. The data must be encrypted with a key that is unique for each customer.

If the encryption key has been corrupted it must not be used for encryption.

You need to ensure that the blob is encrypted.

How should you complete the code segment?

**Code Snippet:**
```csharp
Uri blobUri = ... ; TokenCredential c = ...
byte[] key = ...; string verify = ...
var x = new _____________ ; // Dropdown 1 

if ( _____________ ) { // Dropdown 2

  var o = new BlobClientOptions()
  {
    _____________ = x // Dropdown 3
  };
  var blobClient = new BlobClient(blobUri, c, o);
}
```
### Dropdown 1 Choices:

- AesManaged(key)
- AsnEncodedData(key)
- CustomerProvidedKey(key)
- BlobContainerEncryptionScopeOptions { DefaultEncryptionScope = key }
  
### Dropdown 2 Choices:

- x.IV == verify
- x.RawData == verify
- x.EncryptionKeyHash == verify
- x.PreventEncryptionScopeOverride == verify
(Note: Based on standard Azure.Storage.Blobs SDK, the property typically used to verify the key hash is EncryptionKeyHash)

### Dropdown 3 Choices:

- Version
- Transport
- EncryptionScope
- CustomerProvidedKey

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
1. var x = new CustomerProvidedKey(key)
2. if ( x.EncryptionKeyHash == verify )
3. CustomerProvidedKey

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------

1. var x = new CustomerProvidedKey(key) The requirement states that data must be "encrypted with a key that is unique for each customer." This functionality is provided by Customer-Provided Keys (CPK) in Azure Storage. The SDK class CustomerProvidedKey wraps the raw AES-256 key provided by the client application.

2. if (x.EncryptionKeyHash == verify) The requirement states: "If the encryption key has been corrupted it must not be used." The CustomerProvidedKey object in the Azure SDK automatically calculates the SHA-256 hash of the provided key. You compare this calculated hash (EncryptionKeyHash) against a known, verified hash string (verify) to ensure the key bytes have not been altered or corrupted in memory before attempting to send them to the service.

3. CustomerProvidedKey = x To apply this key to blob operations, you must pass it into the BlobClientOptions. The property name within BlobClientOptions is CustomerProvidedKey. This instructs the client client to send the encryption headers (x-ms-encryption-key, etc.) with requests.

--------------------------------------------------------------------------------
üìå Question 144
--------------------------------------------------------------------------------
You develop a Python application for image rendering that uses GPU resources to optimize rendering processes. You deploy the application to an Azure Container Instances (ACI) Linux container.

The application requires a secret value to be passed when the container is started. The value must only be accessed from within the container.

You need to pass the secret value.

What are two possible ways to achieve this goal? Each correct answer presents a complete solution.

NOTE: Each correct selection is worth one point.

- A. Create an environment variable Set the secureValue property to the secret value.
- B. Add the secret value to the container image. Use a managed identity.
- C. Add the secret value to the application code Set the container startup command.
- D. Add the secret value to an Azure Blob storage account. Generate a SAS token.
- E. Mount a secret volume containing the secret value in a secrets file.

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
- **A.** Create an environment variable Set the secureValue property to the secret value.
- **E.** Mount a secret volume containing the secret value in a secrets file.

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**1. Environment Variables with Secure Values (Option A)**
Azure Container Instances supports setting environment variables for your containers. For sensitive information like passwords or API keys, you can specify these as **secure environment variables**.
*   **How it works:** When you define a secure environment variable (using the `secureValue` property in ARM templates/YAML or `--secure-environment-variables` in CLI), the value is visible to the application running inside the container but is masked/hidden in the container's configuration view in the Azure Portal and CLI output.
*   **Why it fits:** It directly addresses the requirement to pass a value at startup that is accessible within the container but protected from external view.

**2. Secret Volumes (Option E)**
ACI allows you to mount a **secret volume** to a specific path within the container.
*   **How it works:** You define the secrets and the mount path in the container group configuration. When the container starts, the secrets are written to files within that volume in the container's virtual file system (RAM-backed, usually `/run/secrets` or similar). The application reads the file to get the secret.
*   **Why it fits:** This is a standard pattern for secure configuration storage, ensuring secrets are not persisted to disk on the host or exposed in environment variable dumps if the process crashes.

**Why others are incorrect:**
*   **B (Add to image):** Baking secrets into a container image is a major security vulnerability. Anyone with access to the container registry can pull the image and extract the secret.
*   **C (Add to code/startup command):** Hardcoding secrets in source code is insecure. Passing secrets via the startup command string exposes them in process lists (`ps -ef`) and potentially in container logs.
*   **D (Blob SA + SAS):** While you could store configuration in Blob Storage, the container implies a "bootstrap" problem: how do you securely pass the SAS token (which is itself a secret) to the container so it can download the file? Furthermore, A and E are native, direct features of ACI for this specific purpose.

**References:**
*   [Set secure environment variables in Azure Container Instances](https://learn.microsoft.com/en-us/azure/container-instances/container-instances-environment-variables#secure-values)
*   [Mount a secret volume in Azure Container Instances](https://learn.microsoft.com/en-us/azure/container-instances/container-instances-volume-secret)

--------------------------------------------------------------------------------
üìå Question 145
--------------------------------------------------------------------------------
A company maintains multiple web and mobile applications. Each application uses custom in-house identity providers as well as social identity providers.

You need to implement single sign-on (SSO) for all the applications.

What should you do?

- A. Use Azure Active Directory B2C (Azure AD B2C) with custom policies.
- B. Use Azure Active Directory B2B (Azure AD B2B) and enable external collaboration.
- C. Use Azure Active Directory B2C (Azure AD B2C) with user flows.
- D. Use Azure Active Directory B2B (Azure AD B2B).

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
**A.** Use Azure Active Directory B2C (Azure AD B2C) with custom policies.

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**1. Azure AD B2C (Business-to-Consumer)**
The scenario describes customer-facing workloads ("web and mobile applications") utilizing "social identity providers." This is the primary use case for **Azure AD B2C**, which is a Customer Identity and Access Management (CIAM) solution. It allows users to sign in using their preferred social, enterprise, or local account identities to get single sign-on access to your applications.

**2. Custom Policies (Identity Experience Framework)**
While **User Flows** (Option C) provide a quick way to set up standard identity tasks, the requirement specifically mentions **"custom in-house identity providers."**
*   **Custom Policies** are configuration files (XML) that upload to the Identity Experience Framework. They offer the highest level of customization and flexibility.
*   They are necessary when you need to integrate with identity providers that might have complex requirements, require specific claims transformations, or need to interact with REST APIs during the authentication journey to validate data against internal databases. This makes them the definitive choice for integrating generic or complex "custom in-house" providers that might not fit the standard OIDC/SAML templates found in User Flows.

**Why others are incorrect:**
*   **B & D (Azure AD B2B):** Azure AD B2B (Business-to-Business) is designed for **workforce collaboration**, allowing you to invite guest users from partner organizations into your corporate tenant to access resources like SharePoint or Teams. It is not designed to be the identity directory for consumer-facing web/mobile applications engaging with social identities.
*   **C (B2C with User Flows):** User Flows are pre-built policies for common scenarios. While they support standard open-standard federations (like generic OIDC or SAML), they lack the extensibility required if the "custom in-house provider" requires non-standard orchestration or complex logic, making Custom Policies the more complete answer for this specific prompt.

**References:**
*   [What is Azure Active Directory B2C?](https://learn.microsoft.com/en-us/azure/active-directory-b2c/overview)
*   [Azure AD B2C: custom policies overview](https://learn.microsoft.com/en-us/azure/active-directory-b2c/custom-policy-overview)

--------------------------------------------------------------------------------
üìå Question 146
--------------------------------------------------------------------------------
You are developing an Azure Function that calls external APIs by providing an access token for the API. The access token is stored in a secret named **token** in an Azure Key Vault named **mykeyvault**.

You need to ensure the Azure Function can access the token. Which value should you store in the Azure Function App configuration?

- A. `KeyVault:mykeyvault;Secret:token`
- B. `App:Settings:Secret:mykeyvault:token`
- C. `AZUREKVCONNSTR_ https://mykeyveult.vault.ezure.net/secrets/token/`
- D. `@Microsoft.KeyVault(SecretUri=https://mykeyvault.vault.azure.net/secrets/token/)`

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
**D.** `@Microsoft.KeyVault(SecretUri=https://mykeyvault.vault.azure.net/secrets/token/)`

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**1. Azure Key Vault References (Option D)**
Azure App Service and Azure Functions support **Key Vault references**. This feature allows the application to source the value of an application setting effectively from Key Vault, without requiring code changes or managing the secret retrieval logic yourself.
*   **Syntax:** The value of the specific App Setting must be set to the reference format:
    `@Microsoft.KeyVault(SecretUri=https://<vaultname>.vault.azure.net/secrets/<secretname>/<version>)`
*   **Mechanism:** When the app starts, the App Service platform detects this syntax, uses the App's Managed Identity to authenticate with Key Vault, resolves the secret, and exposes the actual secret value as an environment variable to your code.

**Why others are incorrect:**
*   **A & B:** These do not follow any valid syntax for Azure Key Vault references or standard App Service configuration injection. They appear to be made-up formats.
*   **C:** While connection strings are a concept in Azure, the prefix `AZUREKVCONNSTR_` doesn't automatically trigger the Key Vault reference resolution mechanism for a specific application setting in the way required here. The official, supported mechanism for mapping a single secret to a single environment variable is the `@Microsoft.KeyVault` syntax.

**Prerequisites for this solution:**
1.  The Azure Function must have a **System-assigned** or **User-assigned Managed Identity** enabled.
2.  The Managed Identity must be granted access policy (GET permissions) or RBAC role (Key Vault Secrets User) on the Key Vault `mykeyvault`.

**References:**
*   [Use Key Vault references for App Service and Azure Functions](https://learn.microsoft.com/en-us/azure/app-service/app-service-key-vault-references)

--------------------------------------------------------------------------------
üìå Question 147
--------------------------------------------------------------------------------
You are building a web application that uses the Microsoft identity platform for user authentication.

You are implementing user identification for the web application.

You need to retrieve a claim to uniquely identify a user.

Which claim type should you use?

- A. aud
- B. nonce
- C. oid
- D. idp

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
**C.** oid

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**1. Object ID (oid)**
The **oid** claim (Object ID) is the unique, immutable identifier of the user object in the Microsoft identity platform (Azure Active Directory).
*   **Uniqueness:** It uniquely identifies the user within a specific tenant.
*   **Persistence:** Unlike the `sub` (subject) claim, which can sometimes vary depending on the application or client, the `oid` remains consistent across all applications in the tenant for that specific user.
*   **Usage:** It is the recommended claim for performing access checks, mapping users to internal database records, or calling Microsoft Graph APIs.

**Why others are incorrect:**
*   **A (aud):** Stands for "Audience." It identifies the recipient the token is intended for (usually your application's Client ID), not the user.
*   **B (nonce):** Stands for "Number used once." It is a security mechanism used to mitigate token replay attacks. It links a request to a token but does not identify the user.
*   **D (idp):** Stands for "Identity Provider." It records which service authenticated the user (e.g., `live.com`, `facebook.com`, or a specific Azure AD tenant). It identifies the *source* of the identity, not the identity itself.

**References:**
*   [Microsoft identity platform ID tokens - Claims in ID tokens](https://learn.microsoft.com/en-us/entra/identity-platform/id-tokens#claims-in-an-id-token)
*   [Microsoft identity platform access tokens - Claims in access tokens](https://learn.microsoft.com/en-us/entra/identity-platform/access-tokens#claims-in-access-tokens)

--------------------------------------------------------------------------------
üìå Question 148
--------------------------------------------------------------------------------
You are developing an Azure solution.

You need to develop code to access a secret stored in Azure Key Vault.

How should you complete the code segment? To answer, drag the appropriate code segments to the correct location.

**Code Segment:**
```python
def get_secret():
    var1 = os.environ.get("KEY_VAULT_URI")
    # var2 = ___________ ( var1 , ___________ ())
    var3 = var2.get_secret("secret)
    return "secret value {}".format(var3.value)
```

Options:

- DefaultAzureCredential
- ClientSecretCredential
- CloudClients
- SecretClient
- 
--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
- First Box: SecretClient
- 0Second Box: DefaultAzureCredential
```python
def get_secret():
    var1 = os.environ.get("KEY_VAULT_URI")
    var2 = SecretClient(var1, DefaultAzureCredential())
    var3 = var2.get_secret("secret")
    return "secret value {}".format(var3.value)
```
--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
1. SecretClient The variable var2 calls the method .get_secret(). In the Azure SDK for Python azure-keyvault-secrets library, the class responsible for retrieving secrets is SecretClient. The constructor for SecretClient requires the Vault URL (passed here as var1) and a token credential object.

2. DefaultAzureCredential The code segment requires a credential class that is instantiated with empty parentheses ().

DefaultAzureCredential (from azure-identity) is designed to work without constructor arguments in most common scenarios. It automatically attempts multiple authentication mechanisms in a defined order (Environment variables -> Workload Identity -> Managed Identity -> Azure CLI -> etc.), making it the standard choice for flexible authentication.
ClientSecretCredential would be incorrect because it requires mandatory arguments (Tenant ID, Client ID, and Client Secret) to be passed during instantiation.

--------------------------------------------------------------------------------
üìå Question 149 ‚≠ê‚≠ê
--------------------------------------------------------------------------------
You are developing an application to store and retrieve data in Azure Blob storage. The application will be hosted in an on-premises virtual machine (VM). The VM is connected to Azure by using a Site-to-Site VPN gateway connection. The application is secured by using Azure Active Directory (Azure AD) credentials.

The application must be granted access to the Azure Blob storage account with a start time, expiry time, and read permissions. The Azure Blob storage account access must use the Azure AD credentials of the application to secure data access. Data access must be able to be revoked if the client application security is breached.

You need to secure the application access to Azure Blob storage.

Which security features should you use?

**Component: Application (Client)**
1. Storage Account Access Key
2. System-assigned Managed Identity
3. Shared access signature (SAS) token

**Component: Azure Storage (Server)**
1. Stored Access Policy
2. User-assigned Managed Identity
3. Cross-Origin Resource Sharing (CORS)

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
1. **Application (Client):** Shared access signature (SAS) token
2. **Azure Storage (Server):** Stored Access Policy

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
This scenario requires a specific combination of features to meet the requirements of temporary access, revocability, and usage of the application's underlying Azure AD credentials to generate that access.

**1. Application (Client): Shared access signature (SAS) token**

The requirement specifies granting access with a "start time, expiry time, and read permissions." This is the exact definition of a **Shared Access Signature (SAS)**. A SAS provides delegated access to resources in your storage account.

*   **Why SAS?** The question states the app must be granted access with specific time constraints and permissions. An Access Key grants full root access (bad practice for apps), and a Managed Identity is an identity *type*, not a mechanism for granting time-bound, permission-specific access tokens directly for a specific blob operation in this context (though the identity generates the token). The specific artifact the client app uses to present its limited rights to Storage is the SAS token.
*   *Crucial Detail:* Since the app uses Azure AD credentials, it can generate handled "User Delegation SAS" tokens. This meets the requirement "access must use the Azure AD credentials... to secure data access."

**2. Azure Storage (Server): Stored Access Policy**

The most critical requirement for the server-side configuration is: "Data access must be able to be revoked if the client application security is breached."

*   **Why Stored Access Policy?** A standard SAS token, once generated and handed to a client, is valid until it expires. You cannot revoke it easily without regenerating the account keys (which affects all services). However, if you associate a SAS with a **Stored Access Policy**, you can revoke that specific policy on the server (Azure Storage) side. Revoking the policy immediately invalidates all SAS tokens associated with it. usage.
*   *Note:* While User Delegation SAS tokens (backed by Azure AD) are technically revoked by revoking the identity's permissions, the classic mechanism tested for "revocability of a SAS" in Azure exams is the Stored Access Policy.

**Why other options are incorrect:**
*   **Storage Account Access Key:** This provides "root" access to the storage account. It does not natively support granular start/expiry times per request without generating a SAS, and revoking it is disruptive (requires key rotation).
*   **Managed Identity (System or User assigned):** While the question mentions the app uses Azure AD credentials (which implies an identity is involved), the *features* asked for are about the mechanism of access (time-bound, revocable permissions). The Managed Identity is *who* the app is; the SAS and Stored Access Policy are *how* the access is scoped and controlled.
*   **CORS:** This is for browser-based restrictions (e.g., allowing a web font to load from a different domain) and has nothing to do with authentication or authorization permissions.

**References:**
*   [Grant limited access to Azure Storage resources using SAS](https://learn.microsoft.com/en-us/azure/storage/common/storage-sas-overview)
*   [Define a stored access policy](https://learn.microsoft.com/en-us/azure/storage/common/storage-sas-overview#define-a-stored-access-policy)

  --------------------------------------------------------------------------------
üìå Question 150
--------------------------------------------------------------------------------
You manage a data processing application that receives requests from an Azure Storage queue.

You need to manage access to the queue. You have the following requirements:
*   Provide other applications access to the Azure queue.
*   Ensure that you can revoke access to the queue without having to regenerate the storage account keys.
*   Specify access at the queue level and not at the storage account level.

Which type of shared access signature (SAS) should you use?

- A. Service SAS with a stored access policy
- B. Account SAS
- C. User Delegation SAS
- D. Service SAS with ad hoc SAS

--------------------------------------------------------------------------------
‚úÖ Correct Answer
--------------------------------------------------------------------------------
**A. Service SAS with a stored access policy**

--------------------------------------------------------------------------------
üìù Explanation
--------------------------------------------------------------------------------
**Why A is correct (Service SAS with a stored access policy):**
*   **Queue Level (Requirement 3):** A **Service SAS** delegates access to a resource in just one of the storage services: the Blob, Queue, Table, or File service. This meets the requirement to specify access at the queue level.
*   **Revocable without regenerating keys (Requirement 2):** A **Stored Access Policy** is defined on the resource side (the Queue). The SAS token references this policy. If you need to revoke access, you can simply edit or delete the Stored Access Policy on the Queue. This immediately invalidates all SAS tokens associated with that policy without needing to rotate the primary storage account keys (which would disrupt all other applications).

**Why others are incorrect:**
*   **B. Account SAS:** This delegates access to resources in one or more of the storage services. It can be broader than a specific queue (often applying to the whole account's capabilities). More importantly, standard Account SAS tokens are not associated with a stored access policy (stored access policies are currently only supported for Service SAS). To revoke a standalone Account SAS, you typically have to rotate the account keys, violating requirement #2.
*   **C. User Delegation SAS:** This type of SAS is secured with Azure AD credentials. However, it is **only supported for Blob storage** (and Azure Data Lake Storage Gen2). It does not support Azure Queues.
*   **D. Service SAS with ad hoc SAS:** An "ad hoc" SAS has the start time, expiry time, and permissions specified directly in the SAS URI. Once generated and distributed, it cannot be revoked specifically. To stop an ad hoc SAS from working before it expires, you must regenerate the account key used to sign it, which violates requirement #2.

**References:**
*   [Grant limited access to Azure Storage resources using SAS](https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview)
*   [Define a stored access policy](https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview#define-a-stored-access-policy)
